package com.ausgetrunken.ui.wineyard

import androidx.lifecycle.viewModelScope
import com.ausgetrunken.data.local.entities.UserType
import com.ausgetrunken.data.repository.UserRepository
import com.ausgetrunken.domain.repository.AuthenticatedRepository
import com.ausgetrunken.domain.service.WineService
import com.ausgetrunken.domain.service.WineyardService
import com.ausgetrunken.domain.service.WineyardSubscriptionService
import com.ausgetrunken.ui.base.BaseViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.launch

/**
 * REFACTORED VERSION - Compare this to the original!
 * 
 * Notice how clean this is:
 * - No authentication logic in ViewModel
 * - No session restoration handling
 * - No VALID_SESSION_NO_USER parsing
 * - Automatic error handling via base class
 * - Focus purely on business logic
 */
class WineyardDetailViewModelRefactored(
    private val wineyardService: WineyardService,
    private val wineService: WineService,
    private val authenticatedRepository: AuthenticatedRepository,
    private val userRepository: UserRepository,
    private val subscriptionService: WineyardSubscriptionService
) : BaseViewModel() {
    
    private val _uiState = MutableStateFlow(WineyardDetailUiState())
    val uiState: StateFlow<WineyardDetailUiState> = _uiState.asStateFlow()
    
    fun loadWineyard(wineyardId: String) {
        executeWithErrorHandling("loadWineyard") {
            // Repository handles ALL authentication concerns transparently
            authenticatedRepository.executeAuthenticated { userId, userInfo ->
                
                // Clean business logic - no authentication checks needed
                val userFlow = userRepository.getUserById(userId)
                val wineyardFlow = wineyardService.getWineyardById(wineyardId)
                
                combine(userFlow, wineyardFlow) { user, wineyard ->
                    val canEdit = user?.userType == UserType.WINEYARD_OWNER
                    _uiState.value = _uiState.value.copy(
                        wineyard = wineyard,
                        canEdit = canEdit,
                        isLoading = false
                    )
                    
                    // Load wines for this wineyard
                    if (wineyard != null) {
                        loadWines(wineyard.id)
                    }
                    
                    // Load subscription status for customer users
                    if (user?.userType == UserType.CUSTOMER && wineyard != null) {
                        loadSubscriptionStatus(userId, wineyard.id)
                    }
                }.collect {}
            }
        }
    }
    
    private fun loadWines(wineyardId: String) {
        viewModelScope.launch {
            // Simple business logic - no authentication needed here
            wineService.getWinesByWineyard(wineyardId).collect { wines ->
                _uiState.value = _uiState.value.copy(wines = wines)
            }
        }
    }
    
    private fun loadSubscriptionStatus(userId: String, wineyardId: String) {
        viewModelScope.launch {
            try {
                val isSubscribed = subscriptionService.isUserSubscribedToWineyard(userId, wineyardId)
                _uiState.value = _uiState.value.copy(isSubscribed = isSubscribed)
            } catch (e: Exception) {
                handleError(e.toAppError(), "loadSubscriptionStatus")
            }
        }
    }
    
    // ... rest of the ViewModel business logic
    // Notice: NO authentication handling anywhere!
}

/* 
COMPARISON:

OLD APPROACH (what we had):
- 76 lines of authentication logic per ViewModel
- Duplicated session restoration code
- Error-prone copy-paste 
- Mixed concerns (auth + business logic)
- Hard to maintain

NEW APPROACH (this refactored version):
- 0 lines of authentication logic in ViewModel
- Automatic error handling via base class
- Clean separation of concerns
- Easy to maintain and test
- All authentication handled transparently by repository layer
*/